#+TITLE: Protocol creation example
#+AUTHOR: Siddhartha Singh
#+OPTIONS: num:nil \n:t
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+HTML_MATHJAX: align: left indent: 2em tagside: left font: Neo-Euler

#+NAME: startup
#+BEGIN_SRC elisp :exports none
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

#+RESULTS: startup

* Introduction
Below is an example of how a protcol would be translated to cpsa syntax and forge predicates. This should be helpful to anyone trying to model a protocol in forge.
* The protocol
Using the ootway rees protocol here from spore primarily because it is a relatively non trivial example (with more than 2 roles, using long term keys etc.) which can currently be modeled by the protocol (note however that we currently cannot model the attack). Below is the protocol stated in arrow notation:

#+NAME: otway-rees-arrow-notation
#+BEGIN_SRC arrow :tangle temp_arrow.txt :comments link
  A, B, S :   	principal
  M, Na, Nb :   	nonce
  Kas, Kbs, Kab :   	key
  1. A -> B: M, A, B, {Na, M, A, B}Kas
  2. B -> S: M, A, B, {Na, M, A, B}Kas, {Nb, M, A, B}Kbs
  3. S -> B: M, {Na, Kab}Kas, {Nb, Kab}Kbs
  4. B -> A: M, {Na, Kab}Kas
#+END_SRC

* The CPSA file
The CPSA file consists of the protocol description in the defprotocol clause and some of the constraints on the genereated run in the defskeleton clause we discuss both of these in turn.
** defprotocol clause
the defprotocol clause only consists of the distinct roles in the protocol, in this case there are 3 different roles (A,B,S)
we first have to separte out the sends and recieves corresponding to each giving us the below.
Trace of A:
#+BEGIN_SRC arrow :tangle temp_arrow.txt :comments link
  A->: M,A,B,{Na,M,A,B}Kas
  ->A: M,{Na,Kab}Kas
#+END_SRC
Trace of B:
#+BEGIN_SRC arrow :tangle temp_arrow.txt :comments link
  -> B: M, A, B, {Na, M, A, B}Kas
  B ->: M, A, B, {Na, M, A, B}Kas, {Nb, M, A, B}Kb
  -> B: M, {Na, Kab}Kas, {Nb, Kab}Kbs
  B ->: M, {Na, Kab}Kas
#+END_SRC
Trace of S:
#+BEGIN_SRC arrow :tangle temp_arrow.txt :comments link
  -> S: M, A, B, {Na, M, A, B}Kas, {Nb, M, A, B}Kbs
  S ->: M, {Na, Kab}Kas, {Nb, Kab}Kbs
#+END_SRC

There is an additional step before we can translate these to CPSA syntax, if a role has an expression like below in its trace
#+BEGIN_SRC cpsa
  (recv (enc m1 m2 k))
#+END_SRC
Where m1,m2 are some message terms and k is the key, then an additional constraint is added that the agent fulfilling this role in any generated run must know the inverse of the key k. The reason behind this constraint is that if a particular role's trace is placing constraints on the content of an encrypted message means it should be able to see the content of the encrypted message. This protocol has an example of such a case in the trace of B, B receives the terms {Na, M, A, B}Kas and {Na, Kab}Kas whose inverse keys it doesn't know.
To fix this problem we add a new variables m1,m2 which are of type *mesg* meaning they can contain any message and replace the two encrypted terms with this. The trace of B looks like below:
#+BEGIN_SRC arrow
  -> B: M, A, B, m1
  B ->: M, A, B, m1, {Nb, M, A, B}Kb
  -> B: M, m2, {Nb, Kab}Kbs
  B ->: M, m2
#+END_SRC
Now these can be translated to CPSA syntax which gives us the following code
#+BEGIN_SRC cpsa
 (defprotocol ootway_rees basic
  (defrole A
    (vars (a b s name) (m na text) (kab skey))
    (trace
     (send (cat m a b (enc na m a b (ltk a s))))
     (recv (cat m (enc na kab (ltk a s))))
     )
    )
  (defrole B
    (vars (a b s name) (m nb text) (kab skey) (first_a_s_mesg second_a_s_mesg mesg))
    (trace
     (recv (cat m a b first_a_s_mesg))
     (send (cat m a b first_a_s_mesg  (enc nb m a b (ltk b s))  )   )
     (recv (cat m second_a_s_mesg (enc nb kab (ltk b s))))
     (send (cat m second_a_s_mesg))
     )
    )
  (defrole S
    (vars (a b s name) (m na nb text) (kab skey))
    (trace
     (recv (cat m a b (enc na m a b (ltk a s))  (enc nb m a b (ltk b s))  )   )
     (send (cat m (enc na kab (ltk a s)) (enc nb kab (ltk b s))))
     )
    )
)
#+END_SRC
Here m1,m2 have been replaced by first_a_S_mesg and second_a_s_mesg respectively.
** defskeleton
The defskeleton clause in the CPSA grammar is used to state some constraints on the protocol run. Not all constraints can be stated in this form but any additional constraints can be stated through the forge file.
Below is the list of snippets used to generate an honest run, with an explanation of their functions.

Variables clause declares some variables and their types (you will notice these correspond to the initial part of the description of the protocol in the arrow notation which serves the same purpose.
#+BEGIN_SRC cpsa
  (vars (a b s name) (m na nb text) (kab skey) (A role_A) (B role_B) (S role_S))
#+END_SRC

The variables we defines previously have no correspondence with the variables in the role we declared previously, do establish this correspondence we have to add the below defstrand constraints. (Note how the nonces m,na are generated by A and nb is generated by B, since we later place a constraint that these nonces are freshly generated we ensure m,na are present in defstrand A and nb in defstrand B.)
#+BEGIN_SRC cpsa
  (defstrand A 2 (a a) (b b) (s s) (m m) (na na) (kab kab))
  (defstrand B 2 (nb nb))
#+END_SRC

This constraint ensures that the nonces m,na,nb are distinct hence no nonce is resused. The variables a,b,s mapped to variables of the same name a,b,s in A's role are also marked as being distinct to ensure A doesn't communicate with the same agents for B and S.
#+BEGIN_SRC cpsa
  (not-eq a b) (not-eq a s) (not-eq b s)
  (not-eq m na) (not-eq m nb) (not-eq na nb)
#+END_SRC

This deftrace constraint is not strictly required to generate an honest run, one could expand the defstrand constraint to ensure A,B,S agree on the names a,b,s but deftrace is used here as a useful example. (deftrace is also useful for debugging a protocol specification if we see that some run which we expect to be generated is not generated)
The deftrace constraint here enumerates the sequence of sends and recieves which would take place in an honest run of the protocol. The deftrace constraint ensures that the generated run contains this sequence of sends and recieves but allows for other sends/recieves to be interleaved.
#+BEGIN_SRC cpsa
  (deftrace honest_run
    (send-from A (cat m a b (enc na m a b (ltk a s))))
    (recv-by   B (cat m a b (enc na m a b (ltk a s))))
    (send-from B (cat m a b (enc na m a b (ltk a s)) (enc nb m a b (ltk b s))))
    (recv-by   S (cat m a b (enc na m a b (ltk a s)) (enc nb m a b (ltk b s))))
    (send-from S (cat m (enc na kab (ltk a s)) (enc nb kab (ltk b s))))
    (recv-by   A (cat m (enc na kab (ltk a s))))
    (recv-by   B (cat m (enc na kab (ltk a s)) (enc nb kab (ltk b s))))
    (send-from B (cat m (enc na kab (ltk a s))))
  )
#+END_SRC

Finally non-orig on the long term keys ensures the attacker is not able to generate the long term keys. The uniq-orig constraint ensures that all nonces are freshly generated.
#+BEGIN_SRC cpsa
  (non-orig (ltk a s) (ltk b s))
  (uniq-orig m na kab nb)
#+END_SRC


# Local variables
# org-confirm-babel-evaluate: nil
# eval: (progn (org-babel-goto-named-src-block "startup") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# End:


* The forge file
The following text explains different snippets of the forge file in the order which they appear in in the final forge file.

Below code choose what visualization script is used for generating visualization.
#+BEGIN_SRC forge
  option run_sterling "../../crypto_viz_seq.js"
#+END_SRC

wellformed,exec_ootway_rees_A, constrain_skeleton_ootway_rees_0 refer to predicates. wellformed is a predicate common for any protocol, it imposes constraints like agents only being able to send message terms they have learnt. In the CPSA syntax we had defined roles A,B,S. The predicates exec_ootway_rees_A,B,S ensure that strands with role A,B,S only send receive messages which were defined in our role trace clause. These three constraints would also be included in any trace we want to generate for this protocol. constrain_skeleton_ootway_rees_0 predicate corresponds to the defskeleton clause we had included in our CPSA file, the constraints there are transcribed and included in this predicate.
#+BEGIN_SRC forge
  new_ootway_prot_run : run {
      wellformed
      exec_ootway_rees_A
      exec_ootway_rees_B
      exec_ootway_rees_S
      constrain_skeleton_ootway_rees_0
#+END_SRC
These impose the constraint that agents fulfilling the roles A,B,S and Attacker are all distinct since we want to generate an honest run where A,B,S roles wouldn't be played by the Attacker.
#+BEGIN_SRC forge
  let A = ootway_rees_A | { let B = ootway_rees_B | {
  let S = ootway_rees_S | {
      (A.agent != Attacker) and (B.agent != Attacker) and (S.agent != Attacker)
      (A.agent != B.agent) and (A.agent != S.agent) and (B.agent != S.agent)
#+END_SRC
These impose the constraint that agents A,B,S agree on the names a,b,s.
#+BEGIN_SRC forge
  let A_a = ootway_rees_A_a | { let A_b = ootway_rees_A_b | {
  let A_s = ootway_rees_A_s | {
      (A.A_a = A.agent) and (A.A_b = B.agent) and (A.A_s = S.agent)
  } } }
  let B_a = ootway_rees_B_a | { let B_b = ootway_rees_B_b | {
  let B_s = ootway_rees_B_s | {
      (B.B_a = A.agent) and (B.B_b = B.agent) and (B.B_s = S.agent)
  } } }
  let S_a = ootway_rees_S_a | { let S_b = ootway_rees_S_b | {
  let S_s = ootway_rees_S_s | {
      (S.S_a = A.agent) and (S.S_b = B.agent) and (S.S_s = S.agent)
  } } }
#+END_SRC
These ensure that k_ab is not equal to long term keys previously generated.
#+BEGIN_SRC forge
  let k_ab = S.ootway_rees_S_kab | {
      (k_ab != getLTK[A.agent,S.agent]) and (k_ab != getLTK[B.agent,S.agent]) and (k_ab != getLTK[A.agent,B.agent])
  }
#+END_SRC
This imposes the constraint on the size of different sets defined through sig, for an honest run one can compute these by hand.
#+BEGIN_SRC forge
      } } }
  } for
      exactly 8 Timeslot,exactly 24 mesg,exactly 24 text,exactly 24 atomic,
      exactly 7 Key,exactly 0 akey,exactly 7 skey,exactly 0 PrivateKey,exactly 0 PublicKey,
      exactly 4 name,exactly 9 Ciphertext,exactly 4 nonce,exactly 1 KeyPairs,
      exactly 1 ootway_rees_A,exactly 1 ootway_rees_B,
      exactly 1 ootway_rees_S
  for { next is linear }
#+END_SRC
Only including the bound 24 mesg and a few other sets should be enough as mesg is the superset of most of the other sets. However solving is exteremly slow with this, on my machine it didn't terminate after around 25 minutes while with the given constraints it terminates in 2-3 minutes.


* Running the protocol
Now that we have created our CPSA and forge files we can now run this protocol using the following
#+BEGIN_SRC shell
  python3 main_seq_text.py racket_file forge_file --destination_forge_file_path destination_file
#+END_SRC
Above command generates a forge file which includes the content from our *forge_file* and the contents of our *racket_file* transcribed to forge predicates.
To run the forge file you have to run the below command.
#+BEGIN_SRC shell
  racket destination_file
#+END_SRC
The visualizer opens up in your forge file.
